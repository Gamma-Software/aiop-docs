---
description: Des t√¢ches personnalis√©es sont disponibles pour chaque plan d'abonnement. Elles offrent davantage de flexibilit√© et de personnalisation pour un playbook. Cela permet d'ex√©cuter des scripts Python personnalis√©s lors des √©tapes de linting et de post-construction.
---
import { Callout } from "nextra-theme-docs";

# T√¢ches personnalis√©es

Les t√¢ches personnalis√©es permettent plus de flexibilit√© et de personnalisation pour un playbook. Elles donnent la possibilit√© d'ex√©cuter des scripts Python personnalis√©s dans les √©tapes de `lint` et de `post-build`. Vous pourriez par exemple utiliser des t√¢ches personnalis√©es pour :

- `lint`
    - Ajouter des r√®gles sp√©cifique de nommage comme forcer les noms des dossiers √† respecter le format `snake_case`.
    - Ajouter des r√®gles sp√©cifiques de formatage de code comme forcer l'utilisation de `double quotes` pour les cha√Ænes de caract√®res.
    - Ajouter des v√©rifications sur des fichiers de param√©trages comme v√©rifier qu'il n'y a pas d'espace dans les noms de cl√©s.

- `post-build`
    - Ajouter des v√©rifications sur les fichiers g√©n√©r√©s comme v√©rifier que les fichiers de traduction sont bien formatt√©s.
    - G√©n√©rer une image (fond d'√©cran) √† partir des donn√©es du package.

## Configuration

Pour ajouter une t√¢che personnalis√©e, vous devez ajouter une section `custom_jobs` dans votre [fichier de configuration](/docs/configurations/playbook#lint_rules-et-post_scripts). Cette section peut contenir deux sous-sections `lint` et `post_build` qui contiennent les t√¢ches personnalis√©es pour les √©tapes de `lint` et de `post-build` respectivement.

```yaml
custom_jobs:
  lint:
    - name: "CustomLintingTask"
      script: "path/to/your/linting/script.py"
  post_build:
    - name: "CustomPostBuildTask"
      script: "path/to/your/post_build/script.py"
```

### `name`

La classe de la t√¢che personnalis√©e. Ce nom sera utilis√© dans les logs pour identifier la t√¢che qui est en cours d'ex√©cution.

### `script`

Le chemin relative √† la racine du playbook vers le script Python qui sera ex√©cut√©. Ce script doit √™tre un fichier Python valide et doit √™tre accessible depuis le r√©pertoire de travail du playbook.

## Base d'un script personnalis√©

Le script personnalis√© doit √™tre un fichier Python valide. Il est contraint de contenir une classe qui h√©rite de la classe `Job` du module `aiop.libs.job.base`. Cela est valide √† la fois pour les t√¢ches de `lint` et de `post-build`. La classe doit impl√©menter la m√©thode `prerequisites` et `run` qui sera appel√©e lors de l'ex√©cution de la t√¢che.

Voici la structure de base d'un script personnalis√© :

```python showLineNumbers
import os
from pathlib import Path
from aiop.libs.utils.commons import load_playbook_ignore
from aiop.libs.job.base import Job
from aiop.libs.job.metadata import JobResult, JobResultEnum, JobData
from aiop.libs.package import Package
from aiop.core.stages.base import PrerequisiteResults

class CustomTask(Job):
    def __init__(self, stage_name: str):
        self.stage_name = stage_name
        self.name = "CustomTask"

    def prerequisites(self, package: Package, data: JobData) -> PrerequisiteResults:
        return [(True, "")]

    def run(self, package: Package, data: JobData) -> JobResult:
        # Votre logique personnalis√©e ici
        ...
        # Retourne le r√©sultat de la t√¢che
        return JobResult(self.name, JobResultEnum.OK, "CustomTask OK")
```

Le nom de la classe correspond √† la valeur de `name` dans la configuration. La classe doit h√©riter de la classe `Job` du module `aiop.libs.job.base`.

## M√©thodes

### `__init__`


```python {3-5}
...
class CustomTask(Job):
    def __init__(self, stage_name: str):
        self.stage_name = stage_name
        self.name = "CustomTask"
...
```

Le constructeur de la classe. Il prend un param√®tre `stage_name` qui est le nom de l'√©tape dans laquelle la t√¢che est ex√©cut√©e. Ce param√®tre est utilis√© pour identifier l'√©tape dans les logs. Vous devez √©galement nommer la t√¢che en instanciant la variable `self.name`.

### `prerequisites`

```python {4-5}
...
class CustomTask(Job):
    ...
    def prerequisites(self, package: Package, data: JobData) -> PrerequisiteResults:
        return [(True, "")]
...
```

La m√©thode `prerequisites` est invoqu√©e avant l'ex√©cution de la t√¢che. Les t√¢ches sont ex√©cut√©es dans l'ordre dans lequel elles ont √©t√© d√©clar√©es dans le fichier de configuration. Toutefois, si les pr√©requis ne sont pas remplis, la t√¢che ne sera pas ex√©cut√©e au moment pr√©vu, mais elle peut l'√™tre ult√©rieurement. Si ses pr√©requis ne sont jamais satisfaits, une erreur sera signal√©e et la g√©n√©ration du package sera interrompue. Cette m√©thode prend deux param√®tres ([En savoir plus](#param√®tres)). `

Elle doit retourner une liste de tuples. Chaque tuple doit contenir un bool√©en et un message. Si le bool√©en est `True`, la t√¢che sera ex√©cut√©e. Si un des bool√©ens est `False`, la t√¢che ne sera pas ex√©cut√©e et le message sera affich√© dans les logs si le pr√©requis ne sera jamais satisfaits.

### `run`

La m√©thode `run` est appel√©e pour ex√©cuter la t√¢che. Elle doit retourner un objet de type `JobResult` qui contient le r√©sultat de la t√¢che ([En savoir plus sur le retour](#r√©sultat-de-la-t√¢che)). Cette m√©thode contient la logique de la t√¢che personnalis√©e. Vous pouvez faire des appels √† des API, lire et √©crire des fichiers, etc. Il est tout de m√™me recommand√© de ne pas faire des appels bloquants dans cette m√©thode.

<Callout type="warning" emoji="‚ö†Ô∏è">
Vous pouvez alt√©rer le package dans cette m√©thode afin de g√©n√©rer des fichiers ou de modifier des fichiers existants. Vous risquez toutefois de corrompre le package si vous ne faites pas attention. Soyez prudent lorsque vous modifiez le package.
</Callout>

## Param√®tres

### `package`

Le param√®tre `package` est utilisable dans la m√©thode [`prerequisites`](#prerequisites) et [`run`](#run). Ce param√®tre contient les informations sur le package en cours de g√©n√©ration. C'est une variable qui est dynamique et par cons√©quent change au cours du processus de cr√©ation du package, les informations qu'elle contient sont donc susceptibles de changer:

| √©lements | type | description |
| --- | --- | --- |
| `package.cible` | SystemTarget | Syst√®me cible pour construire le package |
| `package.setup_version` | SetupVersion | Version du playbook (`tag`, `version`) |
| `package.temporary_package` | Path | Chemin vers le package en cours de construction |
| `package.raw_declarations` | list | D√©clarations fra√Æchement charg√©es, valid√©es mais pas encore manipul√©es et filtr√©es |
| `package.declarations` | list | Instances de la classe `Declaration` valid√©e mais non filtr√©s en fonction de la compatibilit√© |
| `package.matching_declarations` | list | Instances de la classe `Declaration` compatibles avec la cible |
| `package.computed_declarations` | list | Instances de la classe `Declaration` trait√©es par Aiop |
| `package.results` | dict | R√©sultas des t√¢ches, Dictionnaire regroupant les √©tapes de construction ensuite les t√¢ches avec pour valeur le r√©sultat de la t√¢che `JobResult` |
| `package.session_data` | dict | Donn√©es de session o√π vous pouvez ajouter ce que vous souhaitez transmettre d'une t√¢che √† un autre |

### `data`

Le param√®tre `data` est utilisable dans la m√©thode [`prerequisites`](#prerequisites) et [`run`](#run). Ce param√®tre contient les informations des param√©trages de l‚Äôutilisateur, du playbook et des commandes de l‚Äôutilisateur. C'est une variable qui est statique et par cons√©quent n‚Äôa pas vocation √† changer pendant l‚Äôexecution de Aiop:

| √©lements | type | description |
| --- | --- | --- |
| `data.user_commands` | UserCommands | Les commandes de l‚Äôutilisateur |
| `data.user_config` | UserConfiguration | Les configurations de l‚Äôutilisateur |
| `data.playbook_config` | PlaybookConfiguration | Les configurations du playbook |

## R√©sultat de la t√¢che

La m√©thode `run` doit retourner un objet de type `JobResult` qui contient le r√©sultat de la t√¢che. Cet objet prend trois param√®tres :

| param√®tre | type | description |
| --- | --- | --- |
| `name` | str | Le nom de la t√¢che. G√©n√©ralement, il s'agit du nom de la classe de la t√¢che (ou du nom de la t√¢che). |
| `status` | JobResultEnum | Le statut de la t√¢che. Il doit √™tre une valeur de l'√©num√©ration `JobResultEnum` qui peut √™tre `OK`, `FAIL_NOW`, `FAIL_LATER`, `WARN` ou `SKIP`.|
| `message` | str | Un message qui sera affich√© dans les logs pour d√©crire le r√©sultat de la t√¢che. |

Les valeurs de l'√©num√©ration `JobResultEnum` sont :
| Enum | description |
| --- | --- |
| `OK` | La t√¢che a √©t√© ex√©cut√©e avec succ√®s. |
| `FAIL_NOW` | La t√¢che a √©chou√© et demande √† Aiop d‚Äôarr√™ter la g√©n√©ration du package **tout de suite**.|
| `FAIL_LATER` | La t√¢che a √©chou√© et demande √† Aiop d‚Äôarr√™ter la g√©n√©ration du package **apr√®s** l‚Äôex√©cution de toutes les t√¢ches de l‚Äô√©tape en cours. Cela permet dans certains cas de remonter le plus d‚Äôerreurs possible avant d‚Äôarr√™ter la g√©n√©ration.|
| `WARN` | La t√¢che a √©chou√© mais ne demande pas √† Aiop d‚Äôarr√™ter la g√©n√©ration du package.|
| `SKIP` | La t√¢che n‚Äôa pas √©t√© ex√©cut√©e.|

## Exemple

Voici un exemple de t√¢che personnalis√©e qui v√©rifie que les noms des dossiers respectent le format `snake_case` :

```python showLineNumbers
import os

from pathlib import Path

from aiop.libs.utils.commons import load_playbook_ignore
from aiop.libs.job.base import Job
from aiop.libs.job.metadata import JobResult, JobResultEnum, JobData
from aiop.libs.package import Package
from aiop.core.stages.base import PrerequisiteResults


class NamingConvention(Job):
    def __init__(self, stage_name: str):
        self.stage_name = stage_name
        self.name = "üïµÔ∏è  Naming Convention"

    def prerequisites(self, package: Package, data: JobData) -> PrerequisiteResults:
        return [(True, "")]

    def is_snake_case(self, name):
        return all(x.islower() or x.isdigit() for x in name.split("_"))

    def run(self, package: Package, data: JobData) -> JobResult:
        # Ignorer les dossiers sp√©cifi√©s dans le fichier .aiopignore
        self.ignore_files = load_playbook_ignore(
            data.user_commands.playbook_path, set()
        )

        # R√©cup√©rer la liste des dossiers
        self.folders = []
        for root, dirs, _ in os.walk(data.user_commands.playbook_path):
            dirs[:] = [d for d in dirs if not self.ignore_files(Path(root) / d)]
            self.folders.extend([str(Path(root) / Path(dir)) for dir in dirs])

        # V√©rifier que les noms des dossiers respectent le format snake_case
        not_snake_case_folders = []
        for folder in self.folders:
            if not self.is_snake_case(os.path.basename(folder)):
                not_snake_case_folders.append(folder)

        # Si un ou plusieurs dossiers ne respectent pas le format, retourner un objet JobResult avec le statut FAIL_NOW
        if len(not_snake_case_folders) == 1:
            return JobResult(
                self.name,
                JobResultEnum.FAIL_NOW,
                f"Folder {not_snake_case_folders} is not in snake case",
            )
        elif len(not_snake_case_folders) > 1:
            return JobResult(
                self.name,
                JobResultEnum.FAIL_NOW,
                f"Folders {not_snake_case_folders} are not in snake case",
            )
        return JobResult(self.name, JobResultEnum.OK, "Snake Case rules are respected")
```

Constatez que les prerequis ne sont pas utilis√©s dans cet exemple. Cela est d√ª au fait que la t√¢che ne n√©cessite pas de pr√©requis pour √™tre ex√©cut√©e.

```python {2-3}
...
    def prerequisites(self, package: Package, data: JobData) -> PrerequisiteResults:
        return [(True, "")]
...
```

La m√©thode `is_snake_case` est une m√©thode utilitaire qui v√©rifie si une cha√Æne de caract√®res respecte le format `snake_case`.

```python {2-3}
...
    def is_snake_case(self, name):
        return all(x.islower() or x.isdigit() for x in name.split("_"))
...
```

La m√©thode surcharg√©e `run` contient la logique de la t√¢che. Elle v√©rifie que les noms des dossiers respectent le format `snake_case` et retourne un objet `JobResult` en cons√©quence. Dans le cas o√π un ou plusieurs dossiers ne respectent pas le format, la t√¢che retourne un objet `JobResult` avec le statut `FAIL_NOW` et un message d'erreur pour arr√™ter la g√©n√©ration du package **tout de suite**. Dans le cas contraire, la t√¢che retourne un objet `JobResult` avec le statut `OK`.

```python
...
    def run(self, package: Package, data: JobData) -> JobResult:
        # Ignorer les dossiers sp√©cifi√©s dans le fichier .aiopignore
        self.ignore_files = load_playbook_ignore(
            data.user_commands.playbook_path, set()
        )

        # R√©cup√©rer la liste des dossiers
        self.folders = []
        for root, dirs, _ in os.walk(data.user_commands.playbook_path):
            dirs[:] = [d for d in dirs if not self.ignore_files(Path(root) / d)]
            self.folders.extend([str(Path(root) / Path(dir)) for dir in dirs])

        # V√©rifier que les noms des dossiers respectent le format snake_case
        not_snake_case_folders = []
        for folder in self.folders:
            if not self.is_snake_case(os.path.basename(folder)):
                not_snake_case_folders.append(folder)

        # Si un ou plusieurs dossiers ne respectent pas le format, retourner un objet JobResult avec le statut FAIL_NOW
        if len(not_snake_case_folders) == 1:
            return JobResult(
                self.name,
                JobResultEnum.FAIL_NOW,
                f"Folder {not_snake_case_folders} is not in snake case",
            )
        elif len(not_snake_case_folders) > 1:
            return JobResult(
                self.name,
                JobResultEnum.FAIL_NOW,
                f"Folders {not_snake_case_folders} are not in snake case",
            )
        return JobResult(self.name, JobResultEnum.OK, "Snake Case rules are respected")
```